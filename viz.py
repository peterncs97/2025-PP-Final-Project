#!/usr/bin/env python3
"""
Visualize 2D AABB datasets generated by gen.py.

Supported input:
- BIN (SoA): magic "AASO" + float32 arrays (min_x[], min_y[], max_x[], max_y[])

Saves a PNG image with rectangles drawn in world coordinates.
"""

import argparse
import os
from typing import Tuple
from aabb_io import read_soa_boxes

import matplotlib

# Use non-interactive backend to save PNG without GUI
matplotlib.use("Agg")
import matplotlib.pyplot as plt  # noqa: E402
from matplotlib.patches import Rectangle  # noqa: E402


Box = Tuple[float, float, float, float]  # (min_x, min_y, max_x, max_y)


def parse_args() -> argparse.Namespace:
    p = argparse.ArgumentParser(description="Visualize AABB dataset (CSV or BIN) and save a PNG plot")
    p.add_argument("--in", dest="inp", required=True, help="Input dataset path (.csv or .bin)")
    p.add_argument("--out", dest="out", default=None, help="Output image path (.png). Default: input base + .png")
    p.add_argument("--width", type=float, default=None, help="World width (override). Default: from BIN header or auto from data")
    p.add_argument("--height", type=float, default=None, help="World height (override). Default: from BIN header or auto from data")
    p.add_argument("--dpi", type=int, default=150, help="Output image DPI")
    p.add_argument("--edgecolor", type=str, default="#1f77b4", help="Rectangle edge color")
    p.add_argument("--alpha", type=float, default=0.8, help="Rectangle edge alpha")
    p.add_argument("--linewidth", type=float, default=0.6, help="Rectangle edge linewidth")
    p.add_argument("--pairs", type=str, default=None, help="CSV file with colliding pairs (id1,id2) to highlight")
    p.add_argument("--highlight-color", type=str, default="#d62728", help="Fill/edge color for colliding boxes")
    return p.parse_args()


def load_boxes(inp: str, width: float | None, height: float | None):
    """Load boxes and world dims from input path. Only .bin (SoA) supported."""
    ext = os.path.splitext(inp)[1].lower()
    if ext != ".bin":
        raise ValueError("Unsupported input extension; use .bin")
    boxes, world_w, world_h = read_soa_boxes(inp)
    if width is not None:
        world_w = width
    if height is not None:
        world_h = height
    return boxes, world_w, world_h


def load_pairs(path: str):
    """Return (pairs_list, involved_ids) from a CSV file of id1,id2 rows."""
    import csv as _csv

    involved_ids = set()
    pairs_list: list[tuple[int, int]] = []
    with open(path, "r", newline="") as pf:
        rdr = _csv.reader(pf)
        first = True
        for row in rdr:
            if not row:
                continue
            if first and (row[0].lower().startswith("id") or row[0].lower().startswith("id1")):
                first = False
                continue
            first = False
            a = int(row[0]); b = int(row[1])
            pairs_list.append((a, b))
            involved_ids.add(a); involved_ids.add(b)
    return pairs_list, involved_ids


def create_figure(world_w: float, world_h: float, n: int, dpi: int = 150):
    fig_w = max(4.0, min(12.0, world_w / max(world_h, 1e-6) * 6.0))
    fig_h = 6.0
    fig, ax = plt.subplots(figsize=(fig_w, fig_h), dpi=dpi)
    ax.set_aspect('equal', adjustable='box')
    ax.set_xlim(0, world_w)
    ax.set_ylim(0, world_h)
    ax.set_title(f"AABBs: {n}")
    ax.set_xlabel("x")
    ax.set_ylabel("y")
    return fig, ax


def draw_boxes(ax, boxes, involved_ids, args):
    for idx, (min_x, min_y, max_x, max_y) in enumerate(boxes):
        w = max_x - min_x
        h = max_y - min_y
        if idx in involved_ids:
            rect = Rectangle((min_x, min_y), w, h, fill=True,
                             edgecolor=args.highlight_color, facecolor=args.highlight_color,
                             linewidth=max(0.8, args.linewidth + 0.6), alpha=0.35)
        else:
            rect = Rectangle((min_x, min_y), w, h, fill=False,
                             edgecolor=args.edgecolor, linewidth=args.linewidth, alpha=args.alpha)
        ax.add_patch(rect)


def main() -> None:
    args = parse_args()
    boxes, world_w, world_h = load_boxes(args.inp, args.width, args.height)

    out = args.out
    if not out:
        base, _ = os.path.splitext(args.inp)
        out = base + ".png"
    out_dir = os.path.dirname(out)
    if out_dir:
        os.makedirs(out_dir, exist_ok=True)

    fig, ax = create_figure(world_w, world_h, len(boxes), dpi=args.dpi)

    involved_ids = set()
    if args.pairs:
        involved_ids = load_pairs(args.pairs)

    draw_boxes(ax, boxes, involved_ids, args)

    # Put origin at bottom-left (more natural for world coords)
    ax.invert_yaxis()
    ax.grid(True, linestyle=':', linewidth=0.5, alpha=0.5)
    plt.tight_layout()
    fig.savefig(out)
    plt.close(fig)
    print(f"Saved visualization to {out}")


if __name__ == "__main__":
    main()
