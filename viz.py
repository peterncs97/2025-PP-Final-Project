#!/usr/bin/env python3
"""
Visualize 2D AABB datasets generated by gen.py.

Supported input:
- Text File: start with number of boxes, and followed by boxes (min_x,min_y,max_x,max_y) per line.

Saves a PNG image with rectangles drawn in world coordinates.
"""

import argparse
import os
from typing import Tuple
from aabb_io import read_boxes, read_pairs

import matplotlib

# Use non-interactive backend to save PNG without GUI
matplotlib.use("Agg")
import matplotlib.pyplot as plt  # noqa: E402
from matplotlib.patches import Rectangle  # noqa: E402


Box = Tuple[float, float, float, float]  # (min_x, min_y, max_x, max_y)


def parse_args() -> argparse.Namespace:
    p = argparse.ArgumentParser(description="Visualize AABB dataset (.in) and save a PNG plot")
    p.add_argument("--in", dest="inp", required=True, help="Input dataset path (.in)")
    p.add_argument("--out", dest="out", default=None, help="Output image path (.png). Default: input base + .png")
    p.add_argument("--dpi", type=int, default=150, help="Output image DPI")
    p.add_argument("--edgecolor", type=str, default="#1f77b4", help="Rectangle edge color")
    p.add_argument("--alpha", type=float, default=0.8, help="Rectangle edge alpha")
    p.add_argument("--linewidth", type=float, default=0.6, help="Rectangle edge linewidth")
    p.add_argument("--pairs", type=str, default=None, help=".out file with colliding pairs (id1,id2) to highlight")
    p.add_argument("--highlight-color", type=str, default="#d62728", help="Fill/edge color for colliding boxes")
    return p.parse_args()


def load_boxes(inp: str):
    """Load boxes and world dims from input path."""
    ext = os.path.splitext(inp)[1].lower()
    if ext != ".in":
        raise ValueError("Unsupported input extension; use .in")
    boxes = read_boxes(inp)
    
    # auto world size from data
    world_w = 0.0
    world_h = 0.0
    for (min_x, min_y, max_x, max_y) in boxes:
        world_w = max(world_w, max_x)
        world_h = max(world_h, max_y)
    
    return boxes, world_w, world_h


def load_colliding_ids(path: str):
    pairs_list: List[Tuple[int, int]] = read_pairs(path)
    
    colliding_ids = set()
    for a, b in pairs_list:
        colliding_ids.add(a)
        colliding_ids.add(b)
    return colliding_ids
    

def create_figure(world_w: float, world_h: float, n: int, dpi: int = 150):
    fig_w = max(4.0, min(12.0, world_w / max(world_h, 1e-6) * 6.0))
    fig_h = 6.0
    fig, ax = plt.subplots(figsize=(fig_w, fig_h), dpi=dpi)
    ax.set_aspect('equal', adjustable='box')
    ax.set_xlim(0, world_w)
    ax.set_ylim(0, world_h)
    ax.set_title(f"AABBs: {n}")
    ax.set_xlabel("x")
    ax.set_ylabel("y")
    return fig, ax


def draw_boxes(ax, boxes, involved_ids, args):
    for idx, (min_x, min_y, max_x, max_y) in enumerate(boxes):
        w = max_x - min_x
        h = max_y - min_y
        if idx in involved_ids:
            rect = Rectangle((min_x, min_y), w, h, fill=True,
                             edgecolor=args.highlight_color, facecolor=args.highlight_color,
                             linewidth=max(0.8, args.linewidth + 0.6), alpha=0.35)
        else:
            rect = Rectangle((min_x, min_y), w, h, fill=False,
                             edgecolor=args.edgecolor, linewidth=args.linewidth, alpha=args.alpha)
        ax.add_patch(rect)


def main() -> None:
    args = parse_args()
    boxes, world_w, world_h = load_boxes(args.inp)

    out = args.out
    if not out:
        base, _ = os.path.splitext(args.inp)
        out = base + ".png"
    out_dir = os.path.dirname(out)
    if out_dir:
        os.makedirs(out_dir, exist_ok=True)

    fig, ax = create_figure(world_w, world_h, len(boxes), dpi=args.dpi)

    colliding_ids = set()
    if args.pairs:
        colliding_ids = load_colliding_ids(args.pairs)

    draw_boxes(ax, boxes, colliding_ids, args)
    # Put origin at bottom-left (more natural for world coords)
    ax.invert_yaxis()
    ax.grid(True, linestyle=':', linewidth=0.5, alpha=0.5)
    plt.tight_layout()
    fig.savefig(out)
    plt.close(fig)
    print(f"Saved visualization to {out}")


if __name__ == "__main__":
    main()
